<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Nginx | Hopeful</title>
<meta name="keywords" content="Nginx">
<meta name="description" content="Nginx是一个高性能的 HTTP /反向代理的服务器及电子邮件（IMAP/POP3)代理服务器。官方测试nginx能够支撑5万并发，并且cpu，内存等资源消耗却非常低，运行非常稳定。最重要的是开源，免费，可商用的">
<meta name="author" content="Hopeful">
<link rel="canonical" href="https://xyenvy.github.io/posts/nginx/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.js" onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://xyenvy.github.io/img/Q.gif">
<link rel="icon" type="image/png" sizes="16x16" href="https://xyenvy.github.io/img/Q.gif">
<link rel="icon" type="image/png" sizes="32x32" href="https://xyenvy.github.io/img/Q.gif">
<link rel="apple-touch-icon" href="https://xyenvy.github.io/img/Q.gif">
<link rel="mask-icon" href="https://xyenvy.github.io/img/Q.gif">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script defer src="https://unpkg.com/mermaid@8.8.1/dist/mermaid.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.6.3/dist/jquery.min.js"></script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = ""; 
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<meta property="og:title" content="Nginx" />
<meta property="og:description" content="Nginx是一个高性能的 HTTP /反向代理的服务器及电子邮件（IMAP/POP3)代理服务器。官方测试nginx能够支撑5万并发，并且cpu，内存等资源消耗却非常低，运行非常稳定。最重要的是开源，免费，可商用的" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xyenvy.github.io/posts/nginx/" />
<meta property="og:image" content="https://xyenvy.github.io/posts.images/banner/25.jpg" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-05T00:18:06+08:00" />
<meta property="article:modified_time" content="2022-12-05T00:18:06+08:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://xyenvy.github.io/posts.images/banner/25.jpg" />
<meta name="twitter:title" content="Nginx"/>
<meta name="twitter:description" content="Nginx是一个高性能的 HTTP /反向代理的服务器及电子邮件（IMAP/POP3)代理服务器。官方测试nginx能够支撑5万并发，并且cpu，内存等资源消耗却非常低，运行非常稳定。最重要的是开源，免费，可商用的"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [

        {
          "@type": "ListItem",
          "position":  2 ,
          "name": "📚文章",
          "item": "https://xyenvy.github.io/posts/"
        }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Nginx",
      "item": "https://xyenvy.github.io/posts/nginx/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Nginx",
  "name": "Nginx",
  "description": "Nginx是一个高性能的 HTTP /反向代理的服务器及电子邮件（IMAP/POP3)代理服务器。官方测试nginx能够支撑5万并发，并且cpu，内存等资源消耗却非常低，运行非常稳定。最重要的是开源，免费，可商用的",
  "keywords": [
    "Nginx"
  ],
  "articleBody": "Nginx 简介 一、Nginx概述 1.1 概述 Nginx（“engine x”）是一个高性能的 HTTP /反向代理的服务器及电子邮件（IMAP/POP3)代理服务器。官方测试nginx能够支撑5万并发，并且cpu，内存等资源消耗却非常低，运行非常稳定。最重要的是开源，免费，可商用的。\nNginx还支持热部署，几乎可以做到7 * 24 小时不间断运行，即时运行数个月也不需要重启，还能够在不间断服务的情况下对软件进行升级维护。\n1.2 Nginx应用场景 虚拟主机：一台服务器虚拟出多个网站。\n静态资源服务：提供http资源访问服务。\n反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要yo哪个多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。\n1.3 正向代理 正向代理：一般的访问流程是客户端直接向目标服务器发送请求并获取内容，使用正向代理后，客户端通过配置或其他方式改为向代理服务器发送请求，并指定目标服务器（原始服务器），然后由代理服务器和原始服务器通信，转交请求并获得的内容，再返回给客户端。正向代理隐藏了真实的客户端，为客户端收发请求，使真实客户端对服务器不可见；\n1.4 反向代理 **反向代理：**正好相反。对于客户端来说，反向代理就好像目标服务器。并且客户端不需要进行任何设置。客户端向反向代理发送请求，接着反向代理判断请求走向何处，并将请求转交给客户端，使得这些内容就好像它自己的一样，一次客户端并会并会不感知到反向代理后面的服务，因此不需要客户端做任何设置，只需要把反向代理服务器当成真正的服务器就好了。\n1.5 负载均衡 负载均衡建立在现有网络结构之上，它提供一种链家有效透明的方法扩展网络设备和服务器的宽带、增加吞吐量，加强网络数据处理能力，提高网络的灵活性和可用性。\n1.6 动静分离 为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度，降低原来单个服务器的压力。一般来说，都需要将动态资源和静态资源分开，由于Nginx的高并发和静态资源缓存等特性，经常将静态资源部署在Nginx上。如果请求的是静态资源，直接到静态资源目录获取资源，如果是童泰资源的请求，则利用反向代理的原理，把请求转发给对应后台应用去处理，从而实现动静分离。\n二、Nginx安装 2.1 进入官网下载 2.2 安装相关依赖 2.2.1 第一步 1、 安装pcre\nwget http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz 2、解压文件 tar -zxvf 路径\n3、pcre主目录执行命令 :\n./configure ​ 可能遇到的情况：没有c++支持\n安装c++支持：\nyum install -y gcc gcc-c++ 4、完成后、回到pcre目录下执行\nmake \u0026\u0026 make install 5、查看版本 :\npcre-config --version 2.2.2 第二步，安装其他依赖 zlib openssl\nyum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel 2.3 安装nginx 解压nginx-xx.tar.gz包\ntar -zxvf nginx-xxx.tar.gz 进入解压目录，执行./configure\n./configure make\u0026\u0026make install\nmake \u0026\u0026 make install 2.3 开放端口 #查看开放的端口号 firewall-cmd --list-all #设置开放的端口号 firewall-cmd --add-service=http –permanent sudo firewall-cmd --add-port=80/tcp --permanent #重启防火墙 firewall-cmd –reload 2.4 访问 三、nginx常用命令和配置文件 3.1 常用命令 #查看版本 在/usr/local/nginx/sbin 目录下执行 ./nginx -v #启动nginx 在/usr/local/nginx/sbin 目录下执行 ./nginx #关闭nginx 在/usr/local/nginx/sbin 目录下执行 ./nginx -s stop #重加载nginx 在/usr/local/nginx/sbin 目录下执行 ./nginx -s reload 3.2 配置文件详细讲解 #配置文件位置 位置：/usr/local/nginx/conf/nginx.conf ######Nginx配置文件nginx.conf中文详解##### #定义Nginx运行的用户和用户组 user www www; #nginx进程数，建议设置为等于CPU总核心数。 worker_processes 8; #全局错误日志定义类型，[ debug | info | notice | warn | error | crit ] error_log /usr/local/nginx/logs/error.log info; #进程pid文件 pid /usr/local/nginx/logs/nginx.pid; #指定进程可以打开的最大描述符：数目 #工作模式与连接数上限 #这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。 #现在在linux 2.6内核下开启文件打开数为65535，worker_rlimit_nofile就相应应该填写65535。 #这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。 worker_rlimit_nofile 65535; events { #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型 #是Linux 2.6以上版本内核中的高性能网络I/O模型，linux建议epoll，如果跑在FreeBSD上面，就用kqueue模型。 #补充说明： #与apache相类，nginx针对不同的操作系统，有不同的事件模型 #A）标准事件模型 #Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或poll #B）高效事件模型 #Kqueue：使用于FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X.使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。 #Epoll：使用于Linux内核2.6版本及以后的系统。 #/dev/poll：使用于Solaris 7 11/99+，HP/UX 11.22+ (eventport)，IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。 #Eventport：使用于Solaris 10。 为了防止出现内核崩溃的问题， 有必要安装安全补丁。 use epoll; #单个进程最大连接数（最大连接数=连接数*进程数） #根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cpu跑到100%就行。每个进程允许的最多连接数，理论上每台nginx服务器的最大连接数为。 worker_connections 65535; #keepalive超时时间。 keepalive_timeout 60; #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。 #分页大小可以用命令getconf PAGESIZE 取得。 #[root@web001 ~]# getconf PAGESIZE #4096 #但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。 client_header_buffer_size 4k; #这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。 open_file_cache max=65535 inactive=60s; #这个是指多长时间检查一次缓存的有效信息。 #语法:open_file_cache_valid time 默认值:open_file_cache_valid 60 使用字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息. open_file_cache_valid 80s; #open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。 #语法:open_file_cache_min_uses number 默认值:open_file_cache_min_uses 1 使用字段:http, server, location 这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如果使用更大的值,文件描述符在cache中总是打开状态. open_file_cache_min_uses 1; #语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件是记录cache错误. open_file_cache_errors on; } #设定http服务器，利用它的反向代理功能提供负载均衡支持 http { #文件扩展名与文件类型映射表 include mime.types; #默认文件类型 default_type application/octet-stream; #默认编码 #charset utf-8; #服务器名字的hash表大小 #保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键 值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小. server_names_hash_bucket_size 128; #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。 client_header_buffer_size 32k; #客户请求头缓冲大小。nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。 large_client_header_buffers 4 64k; #设定通过nginx上传文件的大小 client_max_body_size 8m; #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。 #sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。 sendfile on; #开启目录列表访问，合适下载服务器，默认关闭。 autoindex on; #此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用 tcp_nopush on; tcp_nodelay on; #长连接超时时间，单位是秒 keepalive_timeout 120; #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。 fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; fastcgi_buffer_size 64k; fastcgi_buffers 4 64k; fastcgi_busy_buffers_size 128k; fastcgi_temp_file_write_size 128k; #gzip模块设置 gzip on; #开启gzip压缩输出 gzip_min_length 1k; #最小压缩文件大小 gzip_buffers 4 16k; #压缩缓冲区 gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0） gzip_comp_level 2; #压缩等级 gzip_types text/plain application/x-javascript text/css application/xml; #压缩类型，默认就已经包含textml，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。 gzip_vary on; #开启限制IP连接数的时候需要使用 #limit_zone crawler $binary_remote_addr 10m; #负载均衡配置 upstream jh.w3cschool.cn { #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。 server 192.168.80.121:80 weight=3; server 192.168.80.122:80 weight=2; server 192.168.80.123:80 weight=3; #nginx的upstream目前支持4种方式的分配 #1、轮询（默认） #每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。 #2、weight #指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 #例如： #upstream bakend { # server 192.168.0.14 weight=10; # server 192.168.0.15 weight=10; #} #2、ip_hash #每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。 #例如： #upstream bakend { # ip_hash; # server 192.168.0.14:88; # server 192.168.0.15:80; #} #3、fair（第三方） #按后端服务器的响应时间来分配请求，响应时间短的优先分配。 #upstream backend { # server server1; # server server2; # fair; #} #4、url_hash（第三方） #按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 #例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法 #upstream backend { # server squid1:3128; # server squid2:3128; # hash $request_uri; # hash_method crc32; #} #tips: #upstream bakend{#定义负载均衡设备的Ip及设备状态}{ # ip_hash; # server 127.0.0.1:9090 down; # server 127.0.0.1:8080 weight=2; # server 127.0.0.1:6060; # server 127.0.0.1:7070 backup; #} #在需要使用负载均衡的server中增加 proxy_pass http://bakend/; #每个设备的状态设置为: #1.down表示单前的server暂时不参与负载 #2.weight为weight越大，负载的权重就越大。 #3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误 #4.fail_timeout:max_fails次失败后，暂停的时间。 #5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。 #nginx支持同时设置多组的负载均衡，用来给不用的server来使用。 #client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug #client_body_temp_path设置记录文件的目录 可以设置最多3层目录 #location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡 } #虚拟主机的配置 server { #监听端口 listen 80; #域名可以有多个，用空格隔开 server_name www.w3cschool.cn w3cschool.cn; index index.html index.htm index.php; root /data/www/w3cschool; #对******进行负载均衡 location ~ .*.(php|php5)?$ { fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fastcgi.conf; } #图片缓存时间设置 location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$ { expires 10d; } #JS和CSS缓存时间设置 location ~ .*.(js|css)?$ { expires 1h; } #日志格式设定 #$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址； #$remote_user：用来记录客户端用户名称； #$time_local： 用来记录访问时间与时区； #$request： 用来记录请求的url与http协议； #$status： 用来记录请求状态；成功是200， #$body_bytes_sent ：记录发送给客户端文件主体内容大小； #$http_referer：用来记录从那个页面链接访问过来的； #$http_user_agent：记录客户浏览器的相关信息； #通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。 log_format access '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" $http_x_forwarded_for'; #定义本虚拟主机的访问日志 access_log /usr/local/nginx/logs/host.access.log main; access_log /usr/local/nginx/logs/host.access.404.log log404; #对 \"/\" 启用反向代理 location / { proxy_pass http://127.0.0.1:88; proxy_redirect off; proxy_set_header X-Real-IP $remote_addr; #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #以下是一些反向代理的配置，可选。 proxy_set_header Host $host; #允许客户端请求的最大单文件字节数 client_max_body_size 10m; #缓冲区代理缓冲用户端请求的最大字节数， #如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。 #无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误 client_body_buffer_size 128k; #表示使nginx阻止HTTP应答代码为400或者更高的应答。 proxy_intercept_errors on; #后端服务器连接的超时时间_发起握手等候响应超时时间 #nginx跟后端服务器连接超时时间(代理连接超时) proxy_connect_timeout 90; #后端服务器数据回传时间(代理发送超时) #后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据 proxy_send_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时) #连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间） proxy_read_timeout 90; #设置代理服务器（nginx）保存用户头信息的缓冲区大小 #设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小 proxy_buffer_size 4k; #proxy_buffers缓冲区，网页平均在32k以下的设置 #设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k proxy_buffers 4 32k; #高负荷下缓冲大小（proxy_buffers*2） proxy_busy_buffers_size 64k; #设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长 #设定缓存文件夹大小，大于这个值，将从upstream服务器传 proxy_temp_file_write_size 64k; } #设定查看Nginx状态的地址 location /NginxStatus { stub_status on; access_log on; auth_basic \"NginxStatus\"; auth_basic_user_file confpasswd; #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。 } #本地动静分离反向代理配置 #所有jsp的页面均交由tomcat或resin处理 location ~ .(jsp|jspx|do)?$ { proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:8080; } #所有静态文件由nginx直接读取不经过tomcat或resin location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt| pdf|xls|mp3|wma)$ { expires 15d; } location ~ .*.(js|css)?$ { expires 1h; } } } ######Nginx配置文件nginx.conf中文详解##### 四、反向代理 4.1 单端口反向代理 实现效果：打开浏览器，在浏览器地址栏输入 ‘www.123.com’ ，跳转到 linux 系统的 tomcat 主页\n4.1.1 安装 tomcat 将Tomcat安装包复制到linux中\n进入 tomcat 的 bin 目录中，./startup.sh 启动 tomcat 服务器\n对外开放访问的端口号\nfirewall-cmd --add-port=8080/tcp --permanent firewall-cmd -reload 修改本机端口映射\n#1.修改本机 hosts 文件 增加：192.168.0.105 www.123.com 修改nginx配置文件\n访问测试 4.2 多端口反向代理 4.2.1 实现效果 访问 http://192.168.0.105:9001/edu/ 直接跳转到 127.0.0.1:8080 访问 http://192.168.0.105:9001/vod/ 直接跳转到 127.0.0.1:8081 4.2.2 安装两个 Tomcat 分别定义端口为 8001,8002 4.2.3 创建文件夹和测试页面 4.2.4 配置 nginx配置文件 4.2.5 开放端口号 firewall-cmd --add-port=8001/tcp --permanent firewall-cmd --add-port=8002/tcp --permanent firewall-cmd --add-port=9001/tcp --permanent firewall-cmd --reload 4.2.6 测试 1、访问：\n2、访问：http:// 192.168.0.105:9001/vod/a.html\n4.3 负载均衡 1、准备两台 tomcat 服务器，一台8001，一台8002\n2、 在两台 tomcat 里面 webapps 目录中，创建名称是 edu 文件夹，在 edu 文件夹中创建页面a.html，用于测试\n3、配置nginx配置文件\n# 在http模块中配置 upstream myserver{ server 192.168.0.105:8001 weight=1; server 192.168.0.105:8002 weight=2; } # 在server模块配置 listen 80; server_name 192.168.0.105; location / { proxy_pass http://myserver; root html; index index.html index.htm; } 4、nginx提供了几种分配方式(策略)\n1.轮询（默认） 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除。 2.weight weight 代表权重，默认是1，权重越高被分配的客户端越多。 指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。例如： ```bash upstream server_pool{ server 192.168.5.21 weight=10; server 192.168.5.22 weight=10; } 3.ip_hash\n每个请求按访问 ip 的 hash 结果分配，这样每个访客固定一个后端服务器，可以解决session的问题。例如：\nupstream server_pool{ ip_hash server 192.168.5.21:80; server 192.168.5.22:80; } 4.fair(第三方，需要安装第三方模块) 按后端服务器的响应时间来分配请求，响应时间短的优先分配。\nupstream server_pool{ server 192.168.5.21:80; server 192.168.5.22:80; fair; } 5、测试\n五、动静分离 5.1 什么是动静分离 Nginx 动静分离简单来说就是把动态跟静态请求分开，不能理解成只是单纯的把动态页面和\n静态页面物理分离。\n5.2 在linux系统中准备静态资源，用于进行访问 5.3 nginx配置文件 5.4 测试 六、高可用 6.1 Keeplived+Nginx高可用集群（主从模式） 1、需要两台服务器 192.168.0.105 和 192.168.0.102\n2、在两台服务器上安装nginx和keeplived\n#1.安装keepalived yum install keepalived -y #2.keepalived.conf文件 安装之后，在etc里面生成目录 keepalived，有文件 keepalived.conf #3.修改配置文件\n105主服务器\n102副服务器\n#4. 启动keepalived\n#5.测试\n6.2 Keeplived+Nginx 高可用集群（双主模式） 修改配置\n2） 配置 LB-02 节点\n",
  "wordCount" : "7819",
  "inLanguage": "en",
  "image":"https://xyenvy.github.io/posts.images/banner/25.jpg","datePublished": "2022-12-05T00:18:06+08:00",
  "dateModified": "2022-12-05T00:18:06+08:00",
  "author":[{
    "@type": "Person",
    "name": "Hopeful"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://xyenvy.github.io/posts/nginx/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Hopeful",
    "logo": {
      "@type": "ImageObject",
      "url": "https://xyenvy.github.io/img/Q.gif"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    (function () {
        let  arr,reg = new RegExp("(^| )"+"change-themes"+"=([^;]*)(;|$)");
        if(arr = document.cookie.match(reg)) {
        } else {
            if (new Date().getHours() >= 19 || new Date().getHours() < 6) {
                document.body.classList.add('dark');
                localStorage.setItem("pref-theme", 'dark');
            } else {
                document.body.classList.remove('dark');
                localStorage.setItem("pref-theme", 'light');
            }
        }
    })()

    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }
</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://xyenvy.github.io" accesskey="h" title="Hopeful (Alt + H)">
            <img src="https://xyenvy.github.io/img/Q.gif" alt="logo" aria-label="logo"
                 height="35">Hopeful</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://xyenvy.github.io/search" title="🔍 搜索 (Alt &#43; /)" accesskey=/>
                <span>🔍 搜索</span>
                </a>
            </li>
            <li>
                <a href="https://xyenvy.github.io/" title="🏠 主页">
                <span>🏠 主页</span>
                </a>
            </li>
            <li>
                <a href="https://xyenvy.github.io/posts" title="📚 文章">
                <span>📚 文章</span>
                </a>
            </li>
            <li>
                <a href="https://xyenvy.github.io/tags" title="🧩 标签">
                <span>🧩 标签</span>
                </a>
            </li>
            <li>
                <a href="https://xyenvy.github.io/archives/" title="⏱️ 时间轴">
                <span>⏱️ 时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://xyenvy.github.io/about" title="🙋🏻‍♂️ 关于">
                <span>🙋🏻‍♂️ 关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main page">
<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }
</style>

<article class="post-single">
    <div id="single-content">
        <header class="post-header">
            <div class="breadcrumbs"><a href="https://xyenvy.github.io">🏠 主页</a>&nbsp;»&nbsp;<a href="https://xyenvy.github.io/posts/">📚文章</a></div>
            <h1 class="post-title">
                Nginx
            </h1>
            <div class="post-description">
                Nginx是一个高性能的 HTTP /反向代理的服务器及电子邮件（IMAP/POP3)代理服务器。官方测试nginx能够支撑5万并发，并且cpu，内存等资源消耗却非常低，运行非常稳定。最重要的是开源，免费，可商用的
            </div>
            <div class="post-meta">

<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }

    .parent-post-meta {
        display: flex;
        flex-wrap: wrap;
        opacity: 0.8;
    }
</style>

<span class="parent-post-meta">
    <span id="post_meta_style_1">
        <span class="fa fa-calendar-check-o"></span>
        <span>2022-12-05
            &nbsp;&nbsp;
        </span>
    </span>
    
    
    
    
    
    
    
    <span id="post_meta_style_3">
        <span class="fa fa-file-word-o"></span>
        <span>7819字
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_4">
        <span class="fa fa-clock-o"></span>
        <span>16分钟
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_5">
        <span class="fa fa-user-o"></span>
        <span>Hopeful
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_6">
        <span class="fa fa-tags" style="opacity: 0.8"></span>
        <span>
            <span class="post-tags-meta">
                <a href="https://xyenvy.github.io/tags/nginx/" style="color: var(--secondary)!important;">Nginx</a>
            </span>
        </span>
    </span>
</span>
<span style="opacity: 0.8;">
                    <span id="post_meta_style_7">
                        &nbsp;&nbsp;
                        <span class="fa fa-eye" ></span>
                        <span>
                            <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span></span>
                            &nbsp;&nbsp;
                        </span>
                    </span>
                    <span id="post_meta_style_8">
                        <span class="fa fa-commenting-o"></span>
                        <span>
                            <script src="https://cdn.staticfile.org/twikoo/1.5.8/twikoo.all.min.js"></script>
                            <script>
                                let url = document.documentURI
                                
                                let dnsUrl = "https://xyenvy.github.io"
                                let urlSplit = url.split(dnsUrl)
                                let finalUrl = urlSplit[1]
                                if (finalUrl[0] !== '/') {
                                    finalUrl = '/'+finalUrl
                                }
                                twikoo.getCommentsCount({
                                    envId:  null , 
                                region:  null , 
                                urls: [ 
                                    
                                    finalUrl,
                                ],
                                    includeReply: false 
                                }).then(function (res) {
                                    let count = res[0].count
                                    const obj = document.getElementById("comment_count");
                                    obj.innerText = count
                                    
                                    
                                    
                                }).catch(function (err) {
                                    
                                    console.error(err);
                                });
                            </script>
                            <span id="comment_count"></span>
                        </span>
                    </span>
                </span>

</div>
        </header> 
<figure class="entry-cover1"><img style="zoom:;" loading="lazy" src="https://xyenvy.github.io/posts.images/banner/25.jpg" alt="">
    
</figure><aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">文章目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#nginx-%e7%ae%80%e4%bb%8b" aria-label="Nginx 简介">Nginx 简介</a><ul>
                        
                <li>
                    <a href="#%e4%b8%80nginx%e6%a6%82%e8%bf%b0" aria-label="一、Nginx概述">一、Nginx概述</a><ul>
                        
                <li>
                    <a href="#11-%e6%a6%82%e8%bf%b0" aria-label="1.1 概述">1.1 概述</a></li>
                <li>
                    <a href="#12-nginx%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af" aria-label="1.2 Nginx应用场景">1.2 Nginx应用场景</a></li>
                <li>
                    <a href="#13-%e6%ad%a3%e5%90%91%e4%bb%a3%e7%90%86" aria-label="1.3 正向代理">1.3 正向代理</a></li>
                <li>
                    <a href="#14-%e5%8f%8d%e5%90%91%e4%bb%a3%e7%90%86" aria-label="1.4 反向代理">1.4 反向代理</a></li>
                <li>
                    <a href="#15-%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1" aria-label="1.5 负载均衡">1.5 负载均衡</a></li>
                <li>
                    <a href="#16-%e5%8a%a8%e9%9d%99%e5%88%86%e7%a6%bb" aria-label="1.6 动静分离">1.6 动静分离</a></li></ul>
                </li>
                <li>
                    <a href="#%e4%ba%8cnginx%e5%ae%89%e8%a3%85" aria-label="二、Nginx安装">二、Nginx安装</a><ul>
                        
                <li>
                    <a href="#21-%e8%bf%9b%e5%85%a5%e5%ae%98%e7%bd%91%e4%b8%8b%e8%bd%bdhttpnginxorg" aria-label="2.1 进入官网下载">2.1 <a href="http://nginx.org">进入官网下载</a></a></li>
                <li>
                    <a href="#22-%e5%ae%89%e8%a3%85%e7%9b%b8%e5%85%b3%e4%be%9d%e8%b5%96" aria-label="2.2 安装相关依赖">2.2 安装相关依赖</a><ul>
                        
                <li>
                    <a href="#221-%e7%ac%ac%e4%b8%80%e6%ad%a5" aria-label="2.2.1 第一步">2.2.1 第一步</a></li>
                <li>
                    <a href="#222-%e7%ac%ac%e4%ba%8c%e6%ad%a5%e5%ae%89%e8%a3%85%e5%85%b6%e4%bb%96%e4%be%9d%e8%b5%96" aria-label="2.2.2 第二步，安装其他依赖">2.2.2 第二步，安装其他依赖</a></li></ul>
                </li>
                <li>
                    <a href="#23-%e5%ae%89%e8%a3%85nginx" aria-label="2.3 安装nginx">2.3 安装nginx</a></li>
                <li>
                    <a href="#23-%e5%bc%80%e6%94%be%e7%ab%af%e5%8f%a3" aria-label="2.3 开放端口">2.3 开放端口</a></li>
                <li>
                    <a href="#24-%e8%ae%bf%e9%97%ae" aria-label="2.4 访问">2.4 访问</a></li></ul>
                </li>
                <li>
                    <a href="#%e4%b8%89nginx%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4%e5%92%8c%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6" aria-label="三、nginx常用命令和配置文件">三、nginx常用命令和配置文件</a><ul>
                        
                <li>
                    <a href="#31-%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4" aria-label="3.1 常用命令">3.1 常用命令</a></li>
                <li>
                    <a href="#32-%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6%e8%af%a6%e7%bb%86%e8%ae%b2%e8%a7%a3" aria-label="3.2 配置文件详细讲解">3.2 配置文件详细讲解</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%9b%9b%e5%8f%8d%e5%90%91%e4%bb%a3%e7%90%86" aria-label="四、反向代理">四、反向代理</a><ul>
                        
                <li>
                    <a href="#41-%e5%8d%95%e7%ab%af%e5%8f%a3%e5%8f%8d%e5%90%91%e4%bb%a3%e7%90%86" aria-label="4.1 单端口反向代理">4.1 单端口反向代理</a><ul>
                        
                <li>
                    <a href="#411--%e5%ae%89%e8%a3%85-tomcat" aria-label="4.1.1  安装 tomcat">4.1.1  安装 tomcat</a></li></ul>
                </li>
                <li>
                    <a href="#42-%e5%a4%9a%e7%ab%af%e5%8f%a3%e5%8f%8d%e5%90%91%e4%bb%a3%e7%90%86" aria-label="4.2 多端口反向代理">4.2 多端口反向代理</a><ul>
                        
                <li>
                    <a href="#421-%e5%ae%9e%e7%8e%b0%e6%95%88%e6%9e%9c" aria-label="4.2.1 实现效果">4.2.1 实现效果</a></li>
                <li>
                    <a href="#422-%e5%ae%89%e8%a3%85%e4%b8%a4%e4%b8%aa-tomcat-%e5%88%86%e5%88%ab%e5%ae%9a%e4%b9%89%e7%ab%af%e5%8f%a3%e4%b8%ba-80018002" aria-label="4.2.2 安装两个 Tomcat 分别定义端口为 8001,8002">4.2.2 安装两个 Tomcat 分别定义端口为 8001,8002</a></li>
                <li>
                    <a href="#423-%e5%88%9b%e5%bb%ba%e6%96%87%e4%bb%b6%e5%a4%b9%e5%92%8c%e6%b5%8b%e8%af%95%e9%a1%b5%e9%9d%a2" aria-label="4.2.3 创建文件夹和测试页面">4.2.3 创建文件夹和测试页面</a></li>
                <li>
                    <a href="#424-%e9%85%8d%e7%bd%ae-nginx%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6" aria-label="4.2.4 配置 nginx配置文件">4.2.4 配置 nginx配置文件</a></li>
                <li>
                    <a href="#425-%e5%bc%80%e6%94%be%e7%ab%af%e5%8f%a3%e5%8f%b7" aria-label="4.2.5 开放端口号">4.2.5 开放端口号</a></li>
                <li>
                    <a href="#426-%e6%b5%8b%e8%af%95" aria-label="4.2.6 测试">4.2.6 测试</a></li></ul>
                </li>
                <li>
                    <a href="#43-%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1" aria-label="4.3 负载均衡">4.3 负载均衡</a></li></ul>
                </li>
                <li>
                    <a href="#%e4%ba%94%e5%8a%a8%e9%9d%99%e5%88%86%e7%a6%bb" aria-label="五、动静分离">五、动静分离</a><ul>
                        
                <li>
                    <a href="#51-%e4%bb%80%e4%b9%88%e6%98%af%e5%8a%a8%e9%9d%99%e5%88%86%e7%a6%bb" aria-label="5.1 什么是动静分离">5.1 什么是动静分离</a></li>
                <li>
                    <a href="#52-%e5%9c%a8linux%e7%b3%bb%e7%bb%9f%e4%b8%ad%e5%87%86%e5%a4%87%e9%9d%99%e6%80%81%e8%b5%84%e6%ba%90%e7%94%a8%e4%ba%8e%e8%bf%9b%e8%a1%8c%e8%ae%bf%e9%97%ae" aria-label="5.2 在linux系统中准备静态资源，用于进行访问">5.2 在linux系统中准备静态资源，用于进行访问</a></li>
                <li>
                    <a href="#53-nginx%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6" aria-label="5.3 nginx配置文件">5.3 nginx配置文件</a></li>
                <li>
                    <a href="#54-%e6%b5%8b%e8%af%95" aria-label="5.4 测试">5.4 测试</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%85%ad%e9%ab%98%e5%8f%af%e7%94%a8" aria-label="六、高可用">六、高可用</a><ul>
                        
                <li>
                    <a href="#61-keeplivednginx%e9%ab%98%e5%8f%af%e7%94%a8%e9%9b%86%e7%be%a4%e4%b8%bb%e4%bb%8e%e6%a8%a1%e5%bc%8f" aria-label="6.1 Keeplived&#43;Nginx高可用集群（主从模式）">6.1 Keeplived+Nginx高可用集群（主从模式）</a></li>
                <li>
                    <a href="#62-keeplivednginx-%e9%ab%98%e5%8f%af%e7%94%a8%e9%9b%86%e7%be%a4%e5%8f%8c%e4%b8%bb%e6%a8%a1%e5%bc%8f" aria-label="6.2 Keeplived&#43;Nginx 高可用集群（双主模式）">6.2 Keeplived+Nginx 高可用集群（双主模式）</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
        
        activeElement = elements[0];
        const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
        document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
    }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 &&
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
            const id = encodeURI(element.getAttribute('id')).toLowerCase();
            if (element === activeElement){
                document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
            } else {
                document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
            }
        })
    }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;
        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;
    }
</script>
        <div class="post-content"><h2 id="nginx-简介">Nginx 简介<a hidden class="anchor" aria-hidden="true" href="#nginx-简介">#</a></h2>
<h3 id="一nginx概述">一、Nginx概述<a hidden class="anchor" aria-hidden="true" href="#一nginx概述">#</a></h3>
<h4 id="11-概述">1.1 概述<a hidden class="anchor" aria-hidden="true" href="#11-概述">#</a></h4>
<p>Nginx（“engine x”）是一个高性能的 HTTP /反向代理的服务器及电子邮件（IMAP/POP3)代理服务器。官方测试nginx能够支撑5万并发，并且cpu，内存等资源消耗却非常低，运行非常稳定。最重要的是开源，免费，可商用的。</p>
<p>Nginx还支持热部署，几乎可以做到7 * 24 小时不间断运行，即时运行数个月也不需要重启，还能够在不间断服务的情况下对软件进行升级维护。</p>
<h4 id="12-nginx应用场景">1.2 Nginx应用场景<a hidden class="anchor" aria-hidden="true" href="#12-nginx应用场景">#</a></h4>
<ul>
<li>
<p>虚拟主机：一台服务器虚拟出多个网站。</p>
</li>
<li>
<p>静态资源服务：提供http资源访问服务。</p>
</li>
<li>
<p>反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要yo哪个多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。</p>
</li>
</ul>
<h4 id="13-正向代理">1.3 正向代理<a hidden class="anchor" aria-hidden="true" href="#13-正向代理">#</a></h4>
<p><strong>正向代理</strong>：一般的访问流程是客户端直接向目标服务器发送请求并获取内容，使用正向代理后，客户端通过配置或其他方式改为向代理服务器发送请求，并指定目标服务器（原始服务器），然后由代理服务器和原始服务器通信，转交请求并获得的内容，再返回给客户端。正向代理隐藏了真实的客户端，为客户端收发请求，使真实客户端对服务器不可见；</p>
<p><img loading="lazy" src="/images/1.png" alt="1"  />
</p>
<h4 id="14-反向代理">1.4 反向代理<a hidden class="anchor" aria-hidden="true" href="#14-反向代理">#</a></h4>
<p>**反向代理：**正好相反。对于客户端来说，反向代理就好像目标服务器。并且客户端不需要进行任何设置。客户端向反向代理发送请求，接着反向代理判断请求走向何处，并将请求转交给客户端，使得这些内容就好像它自己的一样，一次客户端并会并会不感知到反向代理后面的服务，因此不需要客户端做任何设置，只需要把反向代理服务器当成真正的服务器就好了。</p>
<p><img loading="lazy" src="/images/2.png" alt="2"  />
</p>
<h4 id="15-负载均衡">1.5 负载均衡<a hidden class="anchor" aria-hidden="true" href="#15-负载均衡">#</a></h4>
<p>负载均衡建立在现有网络结构之上，它提供一种链家有效透明的方法扩展网络设备和服务器的宽带、增加吞吐量，加强网络数据处理能力，提高网络的灵活性和可用性。</p>
<p><img loading="lazy" src="/images/3.png" alt="3"  />
</p>
<h4 id="16-动静分离">1.6 动静分离<a hidden class="anchor" aria-hidden="true" href="#16-动静分离">#</a></h4>
<p>为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度，降低原来单个服务器的压力。一般来说，都需要将动态资源和静态资源分开，由于Nginx的高并发和静态资源缓存等特性，经常将静态资源部署在Nginx上。如果请求的是静态资源，直接到静态资源目录获取资源，如果是童泰资源的请求，则利用反向代理的原理，把请求转发给对应后台应用去处理，从而实现动静分离。</p>
<h3 id="二nginx安装">二、Nginx安装<a hidden class="anchor" aria-hidden="true" href="#二nginx安装">#</a></h3>
<h4 id="21-进入官网下载httpnginxorg">2.1 <a href="http://nginx.org">进入官网下载</a><a hidden class="anchor" aria-hidden="true" href="#21-进入官网下载httpnginxorg">#</a></h4>
<h4 id="22-安装相关依赖">2.2 安装相关依赖<a hidden class="anchor" aria-hidden="true" href="#22-安装相关依赖">#</a></h4>
<h5 id="221-第一步">2.2.1 第一步<a hidden class="anchor" aria-hidden="true" href="#221-第一步">#</a></h5>
<p>1、 安装pcre</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>wget http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz
</span></span></code></pre></div><p>2、解压文件 tar -zxvf 路径</p>
<p>3、pcre主目录执行命令 :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>./configure
</span></span></code></pre></div><p>​     可能遇到的情况：没有c++支持</p>
<p><img loading="lazy" src="/images/4.png" alt="4"  />
</p>
<p>安装c++支持：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>yum install -y gcc gcc-c++
</span></span></code></pre></div><p>4、完成后、回到pcre目录下执行</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>make <span style="color:#f92672">&amp;&amp;</span> make install
</span></span></code></pre></div><p>5、查看版本 :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>pcre-config --version
</span></span></code></pre></div><h5 id="222-第二步安装其他依赖">2.2.2 第二步，安装其他依赖<a hidden class="anchor" aria-hidden="true" href="#222-第二步安装其他依赖">#</a></h5>
<p>zlib openssl</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel
</span></span></code></pre></div><h4 id="23-安装nginx">2.3 安装nginx<a hidden class="anchor" aria-hidden="true" href="#23-安装nginx">#</a></h4>
<ol>
<li>
<p>解压nginx-xx.tar.gz包</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>tar -zxvf nginx-xxx.tar.gz
</span></span></code></pre></div></li>
<li>
<p>进入解压目录，执行./configure</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>./configure
</span></span></code></pre></div></li>
<li>
<p>make&amp;&amp;make install</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>make <span style="color:#f92672">&amp;&amp;</span> make install
</span></span></code></pre></div></li>
</ol>
<h4 id="23-开放端口">2.3 开放端口<a hidden class="anchor" aria-hidden="true" href="#23-开放端口">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e">#查看开放的端口号</span>
</span></span><span style="display:flex;"><span>firewall-cmd --list-all
</span></span><span style="display:flex;"><span><span style="color:#75715e">#设置开放的端口号</span>
</span></span><span style="display:flex;"><span>firewall-cmd --add-service<span style="color:#f92672">=</span>http –permanent
</span></span><span style="display:flex;"><span>sudo firewall-cmd --add-port<span style="color:#f92672">=</span>80/tcp --permanent
</span></span><span style="display:flex;"><span><span style="color:#75715e">#重启防火墙</span>
</span></span><span style="display:flex;"><span>firewall-cmd –reload
</span></span></code></pre></div><h4 id="24-访问">2.4 访问<a hidden class="anchor" aria-hidden="true" href="#24-访问">#</a></h4>
<p><img loading="lazy" src="/images/5.png" alt="5"  />
</p>
<h3 id="三nginx常用命令和配置文件">三、nginx常用命令和配置文件<a hidden class="anchor" aria-hidden="true" href="#三nginx常用命令和配置文件">#</a></h3>
<h4 id="31-常用命令">3.1 常用命令<a hidden class="anchor" aria-hidden="true" href="#31-常用命令">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e">#查看版本</span>
</span></span><span style="display:flex;"><span>在/usr/local/nginx/sbin 目录下执行 ./nginx -v
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#启动nginx</span>
</span></span><span style="display:flex;"><span>在/usr/local/nginx/sbin 目录下执行 ./nginx
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#关闭nginx</span>
</span></span><span style="display:flex;"><span>在/usr/local/nginx/sbin 目录下执行 ./nginx -s stop
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#重加载nginx</span>
</span></span><span style="display:flex;"><span>在/usr/local/nginx/sbin 目录下执行 ./nginx -s reload
</span></span></code></pre></div><h4 id="32-配置文件详细讲解">3.2 配置文件详细讲解<a hidden class="anchor" aria-hidden="true" href="#32-配置文件详细讲解">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e">#配置文件位置</span>
</span></span><span style="display:flex;"><span>位置：/usr/local/nginx/conf/nginx.conf
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e">######Nginx配置文件nginx.conf中文详解#####</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#定义Nginx运行的用户和用户组</span>
</span></span><span style="display:flex;"><span>user www www;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#nginx进程数，建议设置为等于CPU总核心数。</span>
</span></span><span style="display:flex;"><span>worker_processes 8;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e">#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]</span>
</span></span><span style="display:flex;"><span>error_log /usr/local/nginx/logs/error.log info;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#进程pid文件</span>
</span></span><span style="display:flex;"><span>pid /usr/local/nginx/logs/nginx.pid;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#指定进程可以打开的最大描述符：数目</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#工作模式与连接数上限</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#现在在linux 2.6内核下开启文件打开数为65535，worker_rlimit_nofile就相应应该填写65535。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。</span>
</span></span><span style="display:flex;"><span>worker_rlimit_nofile 65535;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>events
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#是Linux 2.6以上版本内核中的高性能网络I/O模型，linux建议epoll，如果跑在FreeBSD上面，就用kqueue模型。</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#补充说明：</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#与apache相类，nginx针对不同的操作系统，有不同的事件模型</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#A）标准事件模型</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或poll</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#B）高效事件模型</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#Kqueue：使用于FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X.使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#Epoll：使用于Linux内核2.6版本及以后的系统。</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#/dev/poll：使用于Solaris 7 11/99+，HP/UX 11.22+ (eventport)，IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#Eventport：使用于Solaris 10。 为了防止出现内核崩溃的问题， 有必要安装安全补丁。</span>
</span></span><span style="display:flex;"><span>    use epoll;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#单个进程最大连接数（最大连接数=连接数*进程数）</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cpu跑到100%就行。每个进程允许的最多连接数，理论上每台nginx服务器的最大连接数为。</span>
</span></span><span style="display:flex;"><span>    worker_connections 65535;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#keepalive超时时间。</span>
</span></span><span style="display:flex;"><span>    keepalive_timeout 60;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#分页大小可以用命令getconf PAGESIZE 取得。</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#[root@web001 ~]# getconf PAGESIZE</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#4096</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。</span>
</span></span><span style="display:flex;"><span>    client_header_buffer_size 4k;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。</span>
</span></span><span style="display:flex;"><span>    open_file_cache max<span style="color:#f92672">=</span><span style="color:#ae81ff">65535</span> inactive<span style="color:#f92672">=</span>60s;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#这个是指多长时间检查一次缓存的有效信息。</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#语法:open_file_cache_valid time 默认值:open_file_cache_valid 60 使用字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息.</span>
</span></span><span style="display:flex;"><span>    open_file_cache_valid 80s;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#语法:open_file_cache_min_uses number 默认值:open_file_cache_min_uses 1 使用字段:http, server, location  这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如果使用更大的值,文件描述符在cache中总是打开状态.</span>
</span></span><span style="display:flex;"><span>    open_file_cache_min_uses 1;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件是记录cache错误.</span>
</span></span><span style="display:flex;"><span>    open_file_cache_errors on;
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e">#设定http服务器，利用它的反向代理功能提供负载均衡支持</span>
</span></span><span style="display:flex;"><span>http
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#文件扩展名与文件类型映射表</span>
</span></span><span style="display:flex;"><span>    include mime.types;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#默认文件类型</span>
</span></span><span style="display:flex;"><span>    default_type application/octet-stream;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#默认编码</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#charset utf-8;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#服务器名字的hash表大小</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键 值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小.</span>
</span></span><span style="display:flex;"><span>    server_names_hash_bucket_size 128;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。</span>
</span></span><span style="display:flex;"><span>    client_header_buffer_size 32k;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#客户请求头缓冲大小。nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。</span>
</span></span><span style="display:flex;"><span>    large_client_header_buffers <span style="color:#ae81ff">4</span> 64k;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#设定通过nginx上传文件的大小</span>
</span></span><span style="display:flex;"><span>    client_max_body_size 8m;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。</span>
</span></span><span style="display:flex;"><span>    sendfile on;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#开启目录列表访问，合适下载服务器，默认关闭。</span>
</span></span><span style="display:flex;"><span>    autoindex on;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用</span>
</span></span><span style="display:flex;"><span>    tcp_nopush on;
</span></span><span style="display:flex;"><span>     
</span></span><span style="display:flex;"><span>    tcp_nodelay on;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#长连接超时时间，单位是秒</span>
</span></span><span style="display:flex;"><span>    keepalive_timeout 120;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。</span>
</span></span><span style="display:flex;"><span>    fastcgi_connect_timeout 300;
</span></span><span style="display:flex;"><span>    fastcgi_send_timeout 300;
</span></span><span style="display:flex;"><span>    fastcgi_read_timeout 300;
</span></span><span style="display:flex;"><span>    fastcgi_buffer_size 64k;
</span></span><span style="display:flex;"><span>    fastcgi_buffers <span style="color:#ae81ff">4</span> 64k;
</span></span><span style="display:flex;"><span>    fastcgi_busy_buffers_size 128k;
</span></span><span style="display:flex;"><span>    fastcgi_temp_file_write_size 128k;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#gzip模块设置</span>
</span></span><span style="display:flex;"><span>    gzip on; <span style="color:#75715e">#开启gzip压缩输出</span>
</span></span><span style="display:flex;"><span>    gzip_min_length 1k;    <span style="color:#75715e">#最小压缩文件大小</span>
</span></span><span style="display:flex;"><span>    gzip_buffers <span style="color:#ae81ff">4</span> 16k;    <span style="color:#75715e">#压缩缓冲区</span>
</span></span><span style="display:flex;"><span>    gzip_http_version 1.0;    <span style="color:#75715e">#压缩版本（默认1.1，前端如果是squid2.5请使用1.0）</span>
</span></span><span style="display:flex;"><span>    gzip_comp_level 2;    <span style="color:#75715e">#压缩等级</span>
</span></span><span style="display:flex;"><span>    gzip_types text/plain application/x-javascript text/css application/xml;    <span style="color:#75715e">#压缩类型，默认就已经包含textml，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。</span>
</span></span><span style="display:flex;"><span>    gzip_vary on;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#开启限制IP连接数的时候需要使用</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#limit_zone crawler $binary_remote_addr 10m;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#负载均衡配置</span>
</span></span><span style="display:flex;"><span>    upstream jh.w3cschool.cn <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>     
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。</span>
</span></span><span style="display:flex;"><span>        server 192.168.80.121:80 weight<span style="color:#f92672">=</span>3;
</span></span><span style="display:flex;"><span>        server 192.168.80.122:80 weight<span style="color:#f92672">=</span>2;
</span></span><span style="display:flex;"><span>        server 192.168.80.123:80 weight<span style="color:#f92672">=</span>3;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#nginx的upstream目前支持4种方式的分配</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#1、轮询（默认）</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#2、weight</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#例如：</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#upstream bakend {</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#    server 192.168.0.14 weight=10;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#    server 192.168.0.15 weight=10;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#2、ip_hash</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#例如：</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#upstream bakend {</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#    ip_hash;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#    server 192.168.0.14:88;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#    server 192.168.0.15:80;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#3、fair（第三方）</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#按后端服务器的响应时间来分配请求，响应时间短的优先分配。</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#upstream backend {</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#    server server1;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#    server server2;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#    fair;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#4、url_hash（第三方）</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#upstream backend {</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#    server squid1:3128;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#    server squid2:3128;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#    hash $request_uri;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#    hash_method crc32;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#tips:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#upstream bakend{#定义负载均衡设备的Ip及设备状态}{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#    ip_hash;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#    server 127.0.0.1:9090 down;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#    server 127.0.0.1:8080 weight=2;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#    server 127.0.0.1:6060;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#    server 127.0.0.1:7070 backup;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#在需要使用负载均衡的server中增加 proxy_pass http://bakend/;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#每个设备的状态设置为:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#1.down表示单前的server暂时不参与负载</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#2.weight为weight越大，负载的权重就越大。</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#4.fail_timeout:max_fails次失败后，暂停的时间。</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#nginx支持同时设置多组的负载均衡，用来给不用的server来使用。</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#client_body_temp_path设置记录文件的目录 可以设置最多3层目录</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>     
</span></span><span style="display:flex;"><span>     
</span></span><span style="display:flex;"><span>     
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#虚拟主机的配置</span>
</span></span><span style="display:flex;"><span>    server
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#监听端口</span>
</span></span><span style="display:flex;"><span>        listen 80;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#域名可以有多个，用空格隔开</span>
</span></span><span style="display:flex;"><span>        server_name www.w3cschool.cn w3cschool.cn;
</span></span><span style="display:flex;"><span>        index index.html index.htm index.php;
</span></span><span style="display:flex;"><span>        root /data/www/w3cschool;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#对******进行负载均衡</span>
</span></span><span style="display:flex;"><span>        location ~ .*.<span style="color:#f92672">(</span>php|php5<span style="color:#f92672">)</span>?$
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            fastcgi_pass 127.0.0.1:9000;
</span></span><span style="display:flex;"><span>            fastcgi_index index.php;
</span></span><span style="display:flex;"><span>            include fastcgi.conf;
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>         
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#图片缓存时间设置</span>
</span></span><span style="display:flex;"><span>        location ~ .*.<span style="color:#f92672">(</span>gif|jpg|jpeg|png|bmp|swf<span style="color:#f92672">)</span>$
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            expires 10d;
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>         
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#JS和CSS缓存时间设置</span>
</span></span><span style="display:flex;"><span>        location ~ .*.<span style="color:#f92672">(</span>js|css<span style="color:#f92672">)</span>?$
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            expires 1h;
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>         
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#日志格式设定</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#$remote_user：用来记录客户端用户名称；</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#$time_local： 用来记录访问时间与时区；</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#$request： 用来记录请求的url与http协议；</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#$status： 用来记录请求状态；成功是200，</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#$body_bytes_sent ：记录发送给客户端文件主体内容大小；</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#$http_referer：用来记录从那个页面链接访问过来的；</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#$http_user_agent：记录客户浏览器的相关信息；</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。</span>
</span></span><span style="display:flex;"><span>        log_format access <span style="color:#e6db74">&#39;$remote_addr - $remote_user [$time_local] &#34;$request&#34; &#39;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;$status $body_bytes_sent &#34;$http_referer&#34; &#39;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;&#34;$http_user_agent&#34; $http_x_forwarded_for&#39;</span>;
</span></span><span style="display:flex;"><span>         
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#定义本虚拟主机的访问日志</span>
</span></span><span style="display:flex;"><span>        access_log  /usr/local/nginx/logs/host.access.log  main;
</span></span><span style="display:flex;"><span>        access_log  /usr/local/nginx/logs/host.access.404.log  log404;
</span></span><span style="display:flex;"><span>         
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#对 &#34;/&#34; 启用反向代理</span>
</span></span><span style="display:flex;"><span>        location / <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            proxy_pass http://127.0.0.1:88;
</span></span><span style="display:flex;"><span>            proxy_redirect off;
</span></span><span style="display:flex;"><span>            proxy_set_header X-Real-IP $remote_addr;
</span></span><span style="display:flex;"><span>             
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">#后端的Web服务器可以通过X-Forwarded-For获取用户真实IP</span>
</span></span><span style="display:flex;"><span>            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
</span></span><span style="display:flex;"><span>             
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">#以下是一些反向代理的配置，可选。</span>
</span></span><span style="display:flex;"><span>            proxy_set_header Host $host;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">#允许客户端请求的最大单文件字节数</span>
</span></span><span style="display:flex;"><span>            client_max_body_size 10m;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">#缓冲区代理缓冲用户端请求的最大字节数，</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">#如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">#无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误</span>
</span></span><span style="display:flex;"><span>            client_body_buffer_size 128k;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">#表示使nginx阻止HTTP应答代码为400或者更高的应答。</span>
</span></span><span style="display:flex;"><span>            proxy_intercept_errors on;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">#后端服务器连接的超时时间_发起握手等候响应超时时间</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">#nginx跟后端服务器连接超时时间(代理连接超时)</span>
</span></span><span style="display:flex;"><span>            proxy_connect_timeout 90;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">#后端服务器数据回传时间(代理发送超时)</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">#后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据</span>
</span></span><span style="display:flex;"><span>            proxy_send_timeout 90;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">#连接成功后，后端服务器响应时间(代理接收超时)</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">#连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间）</span>
</span></span><span style="display:flex;"><span>            proxy_read_timeout 90;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">#设置代理服务器（nginx）保存用户头信息的缓冲区大小</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">#设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小</span>
</span></span><span style="display:flex;"><span>            proxy_buffer_size 4k;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">#proxy_buffers缓冲区，网页平均在32k以下的设置</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">#设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k</span>
</span></span><span style="display:flex;"><span>            proxy_buffers <span style="color:#ae81ff">4</span> 32k;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">#高负荷下缓冲大小（proxy_buffers*2）</span>
</span></span><span style="display:flex;"><span>            proxy_busy_buffers_size 64k;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">#设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">#设定缓存文件夹大小，大于这个值，将从upstream服务器传</span>
</span></span><span style="display:flex;"><span>            proxy_temp_file_write_size 64k;
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>         
</span></span><span style="display:flex;"><span>         
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#设定查看Nginx状态的地址</span>
</span></span><span style="display:flex;"><span>        location /NginxStatus <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            stub_status on;
</span></span><span style="display:flex;"><span>            access_log on;
</span></span><span style="display:flex;"><span>            auth_basic <span style="color:#e6db74">&#34;NginxStatus&#34;</span>;
</span></span><span style="display:flex;"><span>            auth_basic_user_file confpasswd;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">#htpasswd文件的内容可以用apache提供的htpasswd工具来产生。</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>         
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#本地动静分离反向代理配置</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#所有jsp的页面均交由tomcat或resin处理</span>
</span></span><span style="display:flex;"><span>        location ~ .<span style="color:#f92672">(</span>jsp|jspx|<span style="color:#66d9ef">do</span><span style="color:#f92672">)</span>?$ <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            proxy_set_header Host $host;
</span></span><span style="display:flex;"><span>            proxy_set_header X-Real-IP $remote_addr;
</span></span><span style="display:flex;"><span>            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
</span></span><span style="display:flex;"><span>            proxy_pass http://127.0.0.1:8080;
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>         
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#所有静态文件由nginx直接读取不经过tomcat或resin</span>
</span></span><span style="display:flex;"><span>        location ~ .*.<span style="color:#f92672">(</span>htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|
</span></span><span style="display:flex;"><span>        pdf|xls|mp3|wma<span style="color:#f92672">)</span>$
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            expires 15d; 
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>         
</span></span><span style="display:flex;"><span>        location ~ .*.<span style="color:#f92672">(</span>js|css<span style="color:#f92672">)</span>?$
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            expires 1h;
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">######Nginx配置文件nginx.conf中文详解#####</span>
</span></span></code></pre></div><h3 id="四反向代理">四、反向代理<a hidden class="anchor" aria-hidden="true" href="#四反向代理">#</a></h3>
<h4 id="41-单端口反向代理">4.1 单端口反向代理<a hidden class="anchor" aria-hidden="true" href="#41-单端口反向代理">#</a></h4>
<p>实现效果：打开浏览器，在浏览器地址栏输入 ‘www.123.com’ ，跳转到 linux 系统的 tomcat 主页</p>
<h5 id="411--安装-tomcat">4.1.1  安装 tomcat<a hidden class="anchor" aria-hidden="true" href="#411--安装-tomcat">#</a></h5>
<ol>
<li>
<p>将Tomcat安装包复制到linux中</p>
</li>
<li>
<p>进入 tomcat 的 bin 目录中，./startup.sh 启动 tomcat 服务器</p>
</li>
<li>
<p>对外开放访问的端口号</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>firewall-cmd --add-port<span style="color:#f92672">=</span>8080/tcp --permanent
</span></span><span style="display:flex;"><span>firewall-cmd -reload
</span></span></code></pre></div></li>
<li>
<p>修改本机端口映射</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e">#1.修改本机 hosts 文件</span>
</span></span><span style="display:flex;"><span>增加：192.168.0.105 www.123.com
</span></span></code></pre></div><p>修改nginx配置文件</p>
<p><img loading="lazy" src="/images/7.png" alt="7"  />
</p>
<ol>
<li>访问测试</li>
</ol>
<h4 id="42-多端口反向代理">4.2 多端口反向代理<a hidden class="anchor" aria-hidden="true" href="#42-多端口反向代理">#</a></h4>
<h5 id="421-实现效果">4.2.1 实现效果<a hidden class="anchor" aria-hidden="true" href="#421-实现效果">#</a></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>访问 http://192.168.0.105:9001/edu/ 直接跳转到 127.0.0.1:8080
</span></span><span style="display:flex;"><span>访问 http://192.168.0.105:9001/vod/ 直接跳转到 127.0.0.1:8081
</span></span></code></pre></div><h5 id="422-安装两个-tomcat-分别定义端口为-80018002">4.2.2 安装两个 Tomcat 分别定义端口为 8001,8002<a hidden class="anchor" aria-hidden="true" href="#422-安装两个-tomcat-分别定义端口为-80018002">#</a></h5>
<p><img loading="lazy" src="/images/9.png" alt="9"  />
</p>
<h5 id="423-创建文件夹和测试页面">4.2.3 创建文件夹和测试页面<a hidden class="anchor" aria-hidden="true" href="#423-创建文件夹和测试页面">#</a></h5>
<p><img loading="lazy" src="/images/10.png" alt="10"  />
</p>
<h5 id="424-配置-nginx配置文件">4.2.4 配置 nginx配置文件<a hidden class="anchor" aria-hidden="true" href="#424-配置-nginx配置文件">#</a></h5>
<p><img loading="lazy" src="/images/11.png" alt="11"  />
</p>
<h5 id="425-开放端口号">4.2.5 开放端口号<a hidden class="anchor" aria-hidden="true" href="#425-开放端口号">#</a></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>firewall-cmd --add-port<span style="color:#f92672">=</span>8001/tcp --permanent
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>firewall-cmd --add-port<span style="color:#f92672">=</span>8002/tcp --permanent
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>firewall-cmd --add-port<span style="color:#f92672">=</span>9001/tcp --permanent
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>firewall-cmd --reload
</span></span></code></pre></div><p><img loading="lazy" src="/images/12.png" alt="12"  />
</p>
<h5 id="426-测试">4.2.6 测试<a hidden class="anchor" aria-hidden="true" href="#426-测试">#</a></h5>
<blockquote>
<p>1、访问：<a href="http://192.168.0.105:9001/edu/a.html"></a></p>
<p><img loading="lazy" src="/images/13.png" alt="13"  />
</p>
<p>2、访问：http:// 192.168.0.105:9001/vod/a.html</p>
<p><img loading="lazy" src="/images/14.png" alt="14"  />
</p>
</blockquote>
<h4 id="43-负载均衡">4.3 负载均衡<a hidden class="anchor" aria-hidden="true" href="#43-负载均衡">#</a></h4>
<p>1、准备两台 tomcat 服务器，一台8001，一台8002</p>
<p>2、 在两台 tomcat 里面 webapps 目录中，创建名称是 edu 文件夹，在 edu 文件夹中创建页面a.html，用于测试</p>
<p>3、配置nginx配置文件</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 在http模块中配置</span>
</span></span><span style="display:flex;"><span>upstream myserver<span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>         server  192.168.0.105:8001 weight<span style="color:#f92672">=</span>1;
</span></span><span style="display:flex;"><span>         server  192.168.0.105:8002 weight<span style="color:#f92672">=</span>2;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 在server模块配置</span>
</span></span><span style="display:flex;"><span>         listen       80;
</span></span><span style="display:flex;"><span>         server_name  192.168.0.105;
</span></span><span style="display:flex;"><span>         location / <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            proxy_pass http://myserver;
</span></span><span style="display:flex;"><span>            root   html;
</span></span><span style="display:flex;"><span>            index  index.html index.htm;
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span></code></pre></div><p>4、nginx提供了几种分配方式(策略)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>1.轮询（默认）
</span></span><span style="display:flex;"><span>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除。
</span></span><span style="display:flex;"><span>2.weight
</span></span><span style="display:flex;"><span>weight 代表权重，默认是1，权重越高被分配的客户端越多。
</span></span><span style="display:flex;"><span>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。例如：
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">```</span>bash
</span></span><span style="display:flex;"><span>upstream server_pool<span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    server 192.168.5.21 weight<span style="color:#f92672">=</span>10;
</span></span><span style="display:flex;"><span>    server 192.168.5.22 weight<span style="color:#f92672">=</span>10;
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>3.ip_hash</p>
<p>每个请求按访问 ip 的 hash 结果分配，这样每个访客固定一个后端服务器，可以解决session的问题。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>upstream server_pool<span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    ip_hash
</span></span><span style="display:flex;"><span>    server 192.168.5.21:80;
</span></span><span style="display:flex;"><span>    server 192.168.5.22:80;
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>4.fair(第三方，需要安装第三方模块)
按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>upstream server_pool<span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    server 192.168.5.21:80;
</span></span><span style="display:flex;"><span>    server 192.168.5.22:80;
</span></span><span style="display:flex;"><span>    fair;
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>5、测试</p>
<p><img loading="lazy" src="/images/15.png" alt="15"  />
</p>
<h3 id="五动静分离">五、动静分离<a hidden class="anchor" aria-hidden="true" href="#五动静分离">#</a></h3>
<h4 id="51-什么是动静分离">5.1 什么是动静分离<a hidden class="anchor" aria-hidden="true" href="#51-什么是动静分离">#</a></h4>
<p>Nginx 动静分离简单来说就是把动态跟静态请求分开，不能理解成只是单纯的把动态页面和</p>
<p>静态页面物理分离。</p>
<p><img loading="lazy" src="/images/16.png" alt="16"  />
</p>
<h4 id="52-在linux系统中准备静态资源用于进行访问">5.2 在linux系统中准备静态资源，用于进行访问<a hidden class="anchor" aria-hidden="true" href="#52-在linux系统中准备静态资源用于进行访问">#</a></h4>
<p><img loading="lazy" src="/images/17.png" alt="17"  />
</p>
<h4 id="53-nginx配置文件">5.3 nginx配置文件<a hidden class="anchor" aria-hidden="true" href="#53-nginx配置文件">#</a></h4>
<p><img loading="lazy" src="/images/18.png" alt="18"  />
</p>
<h4 id="54-测试">5.4 测试<a hidden class="anchor" aria-hidden="true" href="#54-测试">#</a></h4>
<p><img loading="lazy" src="/images/19.png" alt="19"  />
</p>
<p><img loading="lazy" src="/images/20.png" alt="20"  />
</p>
<h3 id="六高可用">六、高可用<a hidden class="anchor" aria-hidden="true" href="#六高可用">#</a></h3>
<h4 id="61-keeplivednginx高可用集群主从模式">6.1 Keeplived+Nginx高可用集群（主从模式）<a hidden class="anchor" aria-hidden="true" href="#61-keeplivednginx高可用集群主从模式">#</a></h4>
<p><img loading="lazy" src="/images/21.png" alt="21"  />
</p>
<p>1、需要两台服务器 192.168.0.105 和 192.168.0.102</p>
<p><img loading="lazy" src="/blog/img/hexo-1660452965551.svgimages/22.png" alt="22"  />
</p>
<p>2、在两台服务器上安装nginx和keeplived</p>
<blockquote>
<p>#1.安装keepalived
yum install keepalived -y
#2.keepalived.conf文件
安装之后，在etc里面生成目录 keepalived，有文件 keepalived.conf
#3.修改配置文件</p>
<p>105主服务器</p>
<p><img loading="lazy" src="/images/23.png" alt="23"  />
</p>
<p>102副服务器</p>
<p><img loading="lazy" src="/images/24.png" alt="24"  />
</p>
<p>#4. 启动keepalived</p>
<p><img loading="lazy" src="/images/25.png" alt="25"  />
</p>
<p>#5.测试</p>
<p><img loading="lazy" src="/images/26.png" alt="26"  />
</p>
<p><img loading="lazy" src="images/27.png" alt="27"  />
</p>
</blockquote>
<h4 id="62-keeplivednginx-高可用集群双主模式">6.2 Keeplived+Nginx 高可用集群（双主模式）<a hidden class="anchor" aria-hidden="true" href="#62-keeplivednginx-高可用集群双主模式">#</a></h4>
<p><img loading="lazy" src="/images/28.png" alt="28"  />
</p>
<p>修改配置</p>
<p><img loading="lazy" src="/images/graphic.png" alt="graphic"  />
</p>
<p>2） 配置 LB-02 节点</p>
<p><img loading="lazy" src="/images/graphic2.png" alt="graphic2"  />
</p>


        </div>

        <footer class="post-footer">
            
<nav class="paginav">
  <a class="prev" href="https://xyenvy.github.io/posts/redis%E9%83%A8%E7%BD%B2%E5%92%8C%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/">
    <span class="title">« 上一页</span>
    <br>
    <span>Redis部署和基础使用</span>
  </a>
  <a class="next" href="https://xyenvy.github.io/posts/%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E6%9C%8D%E5%8A%A1/">
    <span class="title">下一页 »</span>
    <br>
    <span>网络文件共享服务</span>
  </a>
</nav>

        </footer>
    </div>

<style>
    .comments_details summary::marker {
        font-size: 20px;
        content: '👉展开评论';
        color: var(--content);
    }
    .comments_details[open] summary::marker{
        font-size: 20px;
        content: '👇关闭评论';
        color: var(--content);
    }
</style>


<div>
    <details class="comments_details">
        <summary style="cursor: pointer; margin: 50px 0 20px 0;width: 130px;">
            <span style="font-size: 20px;color: var(--content);">...</span>
        </summary>
        <div id="tcomment"></div>
    </details>
    <script src="https://cdn.staticfile.org/twikoo/1.5.8/twikoo.all.min.js">
    </script>
    <script>
        twikoo.init({
            envId:  null ,
        el: "#tcomment",
            lang: 'zh-CN',
            region:  null ,
        path: window.TWIKOO_MAGIC_PATH||window.location.pathname,
        })
    </script>
</div>
</article>
</main>

<footer class="footer">
    <span>
        Copyright
        &copy;
        2022-2023
        <a href="https://xyenvy.github.io" style="color:#939393;">Hopeful</a>
        All Rights Reserved
    </span>
    <a href="https://beian.miit.gov.cn/" target="_blank" style="color:#939393;">黔ICP备2022006994号-2</a>&nbsp;
    <span>
        <a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=null"
           style="display:inline-block;text-decoration:none;height:20px;color:#939393;">
            <img src="/img/beian.png" style="float:left;margin: 0px 5px 0px 0px;"/>
            黔公网安备2022006994号
        </a>
    </span>
    <span id="busuanzi_container">
        <span class="fa fa-user"></span> <span id="busuanzi_value_site_uv"></span>
        <span class="fa fa-eye"></span> <span id="busuanzi_value_site_pv"></span>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <span class="topInner">
        <svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z"/>
        </svg>
        <span id="read_progress"></span>
    </span>
</a>

<script>
    document.addEventListener('scroll', function (e) {
        const readProgress = document.getElementById("read_progress");
        const scrollHeight = document.documentElement.scrollHeight;
        const clientHeight = document.documentElement.clientHeight;
        const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
        readProgress.innerText = ((scrollTop / (scrollHeight - clientHeight)).toFixed(2) * 100).toFixed(0);
    })
</script>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });
</script>
<script>
    let mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 200 || document.documentElement.scrollTop > 200) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };
</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        (function() {
            document.cookie = "change-themes" + "="+ escape ("false");
        })()

        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    });
</script>

<script>
    document.body.addEventListener('copy', function (e) {
        if (window.getSelection().toString() && window.getSelection().toString().length > 50) {
            let clipboardData = e.clipboardData || window.clipboardData;
            if (clipboardData) {
                e.preventDefault();
                let htmlData = window.getSelection().toString() +
                    '\r\n\n————————————————\r\n' +
                    '版权声明：本文为「'+"Hopeful"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                '\r\n原文链接：' + location.href;
                let textData = window.getSelection().toString() +
                    '\r\n\n————————————————\r\n' +
                    '版权声明：本文为「'+"Hopeful"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                '\r\n原文链接：' + location.href;
                clipboardData.setData('text/html', htmlData);
                clipboardData.setData('text/plain', textData);
            }
        }
    });
</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;
        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = '📄复制';

        function copyingDone() {
            copybutton.innerText = '👌🏻已复制!';
            setTimeout(() => {
                copybutton.innerText = '📄复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                let text = codeblock.textContent +
                    '\r\n————————————————\r\n' +
                    '版权声明：本文为「'+"Hopeful"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                '\r\n原文链接：' + location.href;
                navigator.clipboard.writeText(text);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) {}
            selection.removeRange(range);
        });

        let language = codeblock.className.replaceAll("language-", "")
        let macTool = document.createElement("div")
        let macTool1 = document.createElement("div")
        let macTool2 = document.createElement("div")
        let macTool3 = document.createElement("div")
        let languageType = document.createElement("div")
        languageType.innerText = language
        macTool.setAttribute('class', 'mac-tool')
        macTool1.setAttribute('class', 'mac bb1')
        macTool2.setAttribute('class', 'mac bb2')
        macTool3.setAttribute('class', 'mac bb3')
        languageType.setAttribute('class', 'language-type')
        macTool.appendChild(macTool1)
        macTool.appendChild(macTool2)
        macTool.appendChild(macTool3)
        macTool.appendChild(languageType)

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
            container.appendChild(macTool)
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
            container.appendChild(macTool)
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
            container.appendChild(macTool)
        }
    });
</script>
</body>

</html>
